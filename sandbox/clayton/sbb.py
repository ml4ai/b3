# --------------------------------------------------------------------------
# Simple Black Board (SBB)
# Example trivial blackboard from Corkill 1991
# ported from Lisp to python
# --------------------------------------------------------------------------


# the following are Globals used by the SBB

BLACKBOARD = {}
"""
Contains the blackboard database.
Version 1: simple dictionary of blackboard objects stored by name
"""

EVENTS = []
"""
Contains the events generated by each KSA execution.
The events are buffered until execution of the KSA is completed.
Then the events are processed by the control components.
"""

AGENDA = []
"""
Contains the list of activated KSs awaiting execution.
"""

CREATION_EVENT_KSS = []
"""
Contains KS specifications for all KSs that are interested in 
blackboard-object creation events 
(which is the only type of events currently supported).  
The define_creation_ks macro manages this list.
"""

TRACE_LEVEL = 4
"""
The current trace level.
Trace levels from 0 (none) to 3 (highest) are supported.
"""

# --------------------------------------------------------------------------

counter = 0

def gensym(name = 'G'):
    """
    Create a generic name with a guaranteed unique name
    """
    global counter
    g = '{0}_{1}'.format(name, counter)
    counter += 1
    return g

def reset_gensym_counter():
    """
    Reset the gensym counter
    """
    global counter
    counter = 0
    print "counter = {0}".format(counter)

# --------------------------------------------------------------------------

class KS_spec(object):
    """
    Contains the information about a KS needed by the control machinery.
    object_types : list of object types of interest
    ks_function  : name of the function implementing the KS
    """
    global CREATION_EVENT_KSS
    def __init__(self, ks_type_name, object_types, ks_function):
        self.type_name = ks_type_name
        self.object_types = object_types
        self.ks_function = ks_function
        CREATION_EVENT_KSS.append(self)

class BB_object(object):
    """
    Contains the name and data of a blackboard object.
    """
    def __init__(self, name, data):
        self.name = name
        self.data = data
    def __repr__(self):
        return 'BB_object({0},{1})'.format(self.name, self.data)
    def __str__(self):
        return '<BB_object({0},{1})>'.format(self.name, self.data)

def reset_bb_system():
    """
    Resets the system to the initial state.
    """
    global BLACKBOARD, EVENTS, AGENDA
    BLACKBOARD = {}
    EVENTS = []
    AGENDA = []

def undefine_all_kss():
    """
    Removes all KS definitions
    """
    global CREATION_EVENT_KSS
    CREATION_EVENT_KSS = {}

def get_bb_object(name):
    """
    Trivial retrieval of blackboard object by name.
    'Name' must be a string.
    NOTE: This is not actually used in the example below.
          Also, this _could_ be much more fancy kind of pattern-based lookup
            depending on the blackboard repository structure.
    """
    global BLACKBOARD
    return BLACKBOARD[name].data

def creation_event(bb_object):
    """
    Control component code for processing a creation event.
    Determines which KSs are interested in the event and adds them to the agenda.
    NOTE: Does not evaluate the relative importance of activated KSs.
    """
    global CREATION_EVENT_KSS, AGENDA, TRACE_LEVEL
    
    bb_object_type = bb_object.type_name # bb_object.data.ks_type_name
    for ks_spec in CREATION_EVENT_KSS:
        if bb_object_type in ks_spec.object_types:
            ksa = ( ks_spec.ks_function, bb_object )
            if TRACE_LEVEL > 1:
                print "\tActivating {0}".format(ksa)
            AGENDA.append(ksa)

def signal_creation_event(bb_object):
    """
    Signals that 'bb_object' has been created.
    """
    global EVENTS
    EVENTS.append( (creation_event, bb_object.data) )

def make_bb_object(name, data):
    """
    Makes 'object' a blackboard object with name 'name' and signals a 
    creation event.  'Name' must be a string.
    """
    global BLACKBOARD, TRACE_LEVEL
    bb_obj = BB_object(name, data)
    if TRACE_LEVEL > 2:
        print "\tCreating {0} object: {1}".format( type(data), bb_obj )
    BLACKBOARD[name] = bb_obj
    signal_creation_event(bb_obj)
    return bb_obj

EVENT_LIMIT = 10

def control_loop():
    """
    A trivial control loop.
    No opportunistic control is performed, simply LIFO stack (last-in, first-out) scheduling.
    The loop terminates when the agenda is empty.
    """
    global EVENTS, AGENDA, TRACE_LEVEL
    
    epoch = 0
    go = True
    while go:
        if TRACE_LEVEL > 0:
            print "[epoch {0}]".format(epoch)

        event_count = 0
        
        # process events
        for event in EVENTS:
            event_fn, event_data = event[0], event[1]
            if TRACE_LEVEL > 3:
                print "\t\tEvaluating event: ({0} {1})".format(event_fn, event_data)
            event_fn(event_data) # eval the function
            if TRACE_LEVEL > 3:
                print "\t\tEvent eval success."

            if event_count > EVENT_LIMIT:
                break
            event_count += 1
            
        EVENTS = []
        
        # check for stopping condition
        if AGENDA:
            # run the top KSA; LIFO stack agenda
            ksa = AGENDA.pop()
            if TRACE_LEVEL > 0:
                print "\tAGENDA Running: {0}".format(ksa)
            ksa_fn, ksa_data = ksa[0], ksa[1]
            if TRACE_LEVEL > 3:
                print "\t\tEvaluating KSA: ({0} {1})".format(ksa_fn, ksa_data)
            ksa_fn(ksa_data)
            if TRACE_LEVEL > 3:
                print "\t\tKSA eval success."
        else:
            go = False

        epoch += 1
    
    print("\n\nAgenda is empty.  Stopping.")


'''    
def test_def(fn_name):
    fn = lambda: "'{0}' is my name".format(fn_name)
    return fn_name, fn

def define_creation_ks(ks_name, obj_types, ks_function, docstring = None):
    """
    Define KSs interested in creation events.
    'ks_name'   : must be a string and is the name to be given to the 
                  created KS function.
    'obj_types' : is a list of the types of objects for which creation 
                  events are of interest to the KS.
    'ks_function' : 'arglist' and 'body'
                    the argument list and body of the ks function
    """
    CREATION_EVENT_KSS[ks_name] = KS_spec(obj_types, ks_function, docstring)
'''

# --------------------------------------------------------------------------
# A simple "blackboard" application that generates integer values,
# computes their squares, and prints the squares.
# --------------------------------------------------------------------------

"""
Specifies the last integer generated by the generate_integers KS.
"""
STOP_VALUE = 5

class Integer_object(object):
    """
    A blackboard object containing a generated integer.
    """
    type_name = 'Integer_object'
    def __init__(self, value):
        self.value = value
        self.square = None
    def __repr__(self):
        return 'Integer_object({0})'.format(self.value)
    def __str__(self):
        # print '<Integer_object {0}>'.format(self.value)
        return '<Integer_object {0}>'.format(self.value)

class Square_object(object):
    """
    A blackboard object containing a squared integer.
    """
    type_name = 'Square_object'
    def __init__(self, value, integer):
        self.value = value
        self.integer = integer
    def __repr__(self):
        return 'Square_object({0})'.format(self.value)
    def __str__(self):
        # print '<Square_object {0}>'.format(self.value)
        return '<Square_object {0}>'.format(self.value)

# --------------------------------------------------------------------------
# The KS Definitions:
# NOTE: Because the SBB control scheme implements a simple LIFO ordering and
#       the KSs interested in a single type of event are activated in the
#       order in which they appear in the CREATION_EVENT_KSS list, changing
#       the order of definitions below will change the behavior of the app
# NOTE: A bit of a HACK: I define the KS's 'type_name' in the inherited 
#       KS_spec and passing the 'type_name' value as self.__class__.__name__
# --------------------------------------------------------------------------
    
'''
define_creation_ks('compute-squares',
                   ( Integer_object ),
                   lambda bb_obj: make_bb_object(gensym(),
                                                 Square_object(bb_obj.value * bb_obj.value,
                                                               bb_obj)))
'''

class Compute_Squares_KS(KS_spec):
    """ KS that computes the square of its 'bb_obj' argument. """
    def __init__(self):
        KS_spec.__init__(self, self.__class__.__name__, ( Integer_object.type_name, ), self)
    def __call__(self, bb_obj):
        value = bb_obj.value
        square_obj = Square_object(value * value, bb_obj)
        make_bb_object(gensym(), square_obj)
        bb_obj.square = square_obj

class Generate_Integers_KS(KS_spec):
    """ 
    KS that creates new Integer_objects with a value that is 1 larger
    than its 'bb_obj' argument.  Creation stops when the value exceeds 
    STOP_VALUE.
    """
    def __init__(self):
        KS_spec.__init__(self, self.__class__.__name__, ( Integer_object.type_name, ), self)
    def __call__(self, bb_obj):
        if bb_obj.value < STOP_VALUE:
            make_bb_object(gensym(), Integer_object(bb_obj.value + 1))

class Print_Squares_KS(KS_spec):
    """
    KS that prints the value of the created Square_object (contained
    in the 'bb_obj' argument).
    """
    def __init__(self):
        KS_spec.__init__(self, self.__class__.__name__, ( Square_object.type_name, ), self)
    def __call__(self, bb_obj):
        print "** Square: {0}".format(bb_obj.value)

# --------------------------------------------------------------------------
        
# Instantiate KSs
Compute_Squares_KS()
Generate_Integers_KS()
Print_Squares_KS()

# --------------------------------------------------------------------------

def run_application():
    """
    The top-level applicaiton function that runs (and reruns) the simple
    BB application.
    """
    reset_bb_system()
    make_bb_object(gensym(), Integer_object(1))
    control_loop()

